I"Ť<blockquote>
  <p>WebRTC is a new front in the long war for an open and unencumbered web<br />
WebRTC는 개방적이고 방해받지 않는 웹을위한 긴 전쟁의 새로운 전선입니다. 
- <a href="https://hacks.mozilla.org/2012/03/video-mobile-and-the-open-web/">Brendan Eich</a></p>
</blockquote>

<h2 id="바로가기">바로가기</h2>

<ul>
  <li><a href="#클라이언트 구성">본문</a></li>
  <li><a href="#signaling-server-구현">시그널링 서버 코드</a></li>
  <li><a href="#caller-callee-코드-통합-및-정리">클라이언트 코드</a></li>
</ul>

<h2 id="개요">개요</h2>

<p>일반적인 웹 서비스에서 사용자간의 데이터 전송을 하기 위해서는 고정된 접근경로(ip / domain)을 가진 웹서버에 두 사용자가 
접속하여 거쳐서 서로 통신을 한다.</p>

<div class="mermaid"> 
sequenceDiagram
Participant 철수
Participant server
Participant 영희
철수-&gt;&gt;server: 영희야(18byte)
server-&gt;&gt;영희: 영희야(18byte)
영희--&gt;&gt;server: 꺼져(6byte)
server--&gt;&gt;철수: 꺼져(6byte)
Note over 철수: send: 18byte, recieve: 6byte
Note over 영희: send: 6byte, recieve: 18byte
Note over server: send: 24byte, recieve: 24byte 
</div>

<p>위 다이어그램에서 보듯이 실제 주고 받는 정보의 양에 비해 중계서버의 부담이 상당하다. 만약 실시간 비디오와 같은 대량의 데이터가
이러한 방식으로 오간다면 상당한 비용이 필요할 뿐 아니라 서버 컨디션에 따라 서비스 품질에도 상당한 영향이 있을것이다.
만약 데이터를 사용자간에 직접 주고받을 수 있다면 (peer-to-peer) 서버가 부담하는 트래픽은 거의 없어질 수 있고
많은 비용 절감과 함께 사용자 입장에서도 품질 향상를 이룰 수 있다.</p>

<div class="mermaid"> 
sequenceDiagram
Participant 철수
Participant server
Participant 영희
철수-&gt;&gt;영희: 영희야(18byte)
영희--&gt;&gt;철수: 꺼져(6byte)
Note over 철수: send: 18byte, recieve: 6byte
Note over 영희: send: 6byte, recieve: 18byte 
</div>

<p>또한 멀리 봤을때, Brendan Eich가 언급한 것과 같이 중앙집중적인 커뮤니케이션에서 벗어나 더 개방적인 웹을 위한 기본 방법이 될 수 있다.</p>

<p>하지만 이를 실제 구현하기 위해 부딪치게 되는 이러한 여러가지 기술적 과제들은 간단한 문제가 아니며 웹브라우저를 통한
전통적인 http 통신으로는 해결하기 어렵다. 다행히 이 문제를 해결하기 위한 공통적인 구현은 <a href="https://webrtc.org/">WebRTC</a> 
라는 오픈소스 기술로 표준화 되어있으며, 각 브라우저 벤더사에서 구현하여 모던 브라우저에서 
간단한 <a href="https://developer.mozilla.org/ko/docs/Web/API/WebRTC_API">javascript API</a> 사용만으로 구현할 수 있게 되었다.</p>

<p>다만 이러한 API 를 사용한다 해도 문제는 그리 간단하지 않다. 
실제 구현시 발생하는 여러가지 문제들을 best practice로 해결하기란 쉽지 않은 일이며, 
<a href="https://www.npmjs.com/search?q=webrtc&amp;ranking=popularity">잘 구현된 라이브러리나</a>
<a href="https://www.html5rocks.com/ko/tutorials/webrtc/infrastructure/#readymade-signaling-servers">웹서비스</a>
를 사용하는 것이 현명할 수도 있다.</p>

<p>하지만 그렇다 하더라도 그 기반을 이루고 있는 기술과 api에 대한 이해는 필수적이다.</p>

<p>이 연재는 p2p 비디오 스트리밍을 위한 기술적 요구사항들과 이를 해결하기 위한 WebRTC 기술의 구성요소들, 
구현시 발생가능한 문제들에 대한 기본적인 해결방법에 대한 이해를 위한 스터디 기록이다.</p>

<p>목표는 가장 단순한 구현부터 시작해서 AWS를 통해 모바일 크로스 플랫폼 간에 1:1 p2p통신을 이용하여 영상 및 채팅 메시지를 
전송할수 있도록 구현하는 것 까지이다.</p>

<p>boilerplate code를 줄이고 빠른 시작이 가능하게 하기 위해 별도의 bundler를 사용하지 않고 es6의 module API를 사용할 것이다.</p>

<h2 id="클라이언트-구성">클라이언트 구성</h2>

<p>1:1 화상채팅을 연결하는 단계의 로직은 요청하는 쪽과 받는쪽의 로직으로 나눌 수 있다.
완성단계에서는 하나의 화면으로 합쳐지겠지만 과정의 이해를 쉽게 하기위해 처음에는 두 화면으로 나누어서 구성한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/
└─ client/
   ├ caller.html
   ├ caller.js
   ├ callee.html
   └ callee.js
</code></pre></div></div>

<h2 id="화면에-웹캠-스트리밍-표시하기">화면에 웹캠 스트리밍 표시하기</h2>

<p>복잡한 기술적 사항을 다루느라 흥미를 잃기 전에 바로 화면부터 띄워보자.</p>

<p><strong>caller.html</strong>, <strong>callee.html</strong> 동일하게</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;!doctype html&gt;</span>
<span class="nt">&lt;html&gt;</span>
<span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;meta</span> <span class="na">charset=</span><span class="s">"UTF-8"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;title&gt;</span>WebRTC<span class="nt">&lt;/title&gt;</span>
<span class="nt">&lt;/head&gt;</span>
<span class="nt">&lt;body&gt;</span>
<span class="c">&lt;!--내 얼굴이 나올 video 요소--&gt;</span>
<span class="nt">&lt;video</span> <span class="na">id=</span><span class="s">"localVideo"</span> <span class="na">autoplay</span> <span class="na">width=</span><span class="s">"480px"</span><span class="nt">&gt;&lt;/video&gt;</span>
<span class="c">&lt;!--상대방의 얼굴이 나올 video 요소--&gt;</span>
<span class="nt">&lt;video</span> <span class="na">id=</span><span class="s">"remoteVideo"</span> <span class="na">autoplay</span> <span class="na">width=</span><span class="s">"480px"</span><span class="nt">&gt;&lt;/video&gt;</span>
<span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"caller.js(또는 callee.js)"</span><span class="nt">&gt;&lt;/script&gt;</span>
<span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>

<p><strong>caller.js</strong>, <strong>callee.js</strong> 동일하게</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">navigator</span><span class="p">.</span><span class="nx">mediaDevices</span>
  <span class="p">.</span><span class="nx">getUserMedia</span><span class="p">({</span> <span class="na">video</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="na">audio</span><span class="p">:</span> <span class="kc">false</span> <span class="p">})</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">mediaStream</span> <span class="o">=&gt;</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">localVideo</span><span class="dl">'</span><span class="p">).</span><span class="nx">srcObject</span> <span class="o">=</span> <span class="nx">mediaStream</span><span class="p">);</span>
</code></pre></div></div>

<p>위와 같이 작성하고 caller.html 또는 callee.html 을 브라우저로 띄우면 사용자에게 비디오 전송 허용 여부를 묻고
이후 웹캠 화면이 브라우저에 나타나기 시작한다.</p>

<h2 id="rtc-연결-생성하기-1">RTC 연결 생성하기 (1)</h2>

<p>WebRTC 통신은 <code class="language-plaintext highlighter-rouge">RTCPeerConnection</code> 객체를 통해서 이루어진다. caller와 callee는 이 객체를 통해서 상대편 단말에 메시지를 보내
두 가지 정보를 교환해야 하는데</p>

<ul>
  <li>어떤 경로를 통해서 접근해야 하는지 <strong>(SDP - Session Description Protocol)</strong> 와</li>
  <li>어떤 형식으로 데이터를 주고 받을지 <strong>(ICE - Interactive Connectivity Establishment)</strong> 를 협의한 후 실제 데이터를 주고 받게 된다.</li>
</ul>

<h3 id="sdp-교환-단계">SDP 교환 단계</h3>

<p>두 클라이언트는 아래 과정을 거쳐서 서로에게 어떻게 접속해야 할지에 대한 정보 (localDescription, remoteDescription)를 교환한다.</p>

<div class="mermaid"> 
sequenceDiagram
caller-&gt;&gt;caller: createOffer()
Note left of caller: LocalDescription = offer
caller-&gt;&gt;callee: offerSDP
Note right of callee: RemoteDescription = offer
callee-&gt;&gt;callee: createAnswer()
Note right of callee: LocalDescription = answer
callee--&gt;&gt;caller: answerSDP
Note left of caller: RemoteDescription = answer 
</div>

<p>아래 예제는 클라이언트 간 메시지 교환을 위한 <code class="language-plaintext highlighter-rouge">onMessage</code>, <code class="language-plaintext highlighter-rouge">sendMessage</code> 메소드가 구현되어 있다고 가정하고 작성한 것이다.<br />
(이 두 메소드의 구현은 조금 뒤에 다룬다.)</p>

<p>메시지 교환 순서의 이해를 돕기 위해 caller, callee 사이에 메시지가 오가는 순서대로 작성한다.</p>

<p><strong>caller.js</strong></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*...앞의 예제 내용에 이어서...*/</span>
<span class="kd">const</span> <span class="nx">rtcPeerConnection</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">RTCPeerConnection</span><span class="p">();</span>
<span class="nx">rtcPeerConnection</span><span class="p">.</span><span class="nx">addStream</span><span class="p">(</span><span class="nx">mediaStream</span><span class="p">);</span> <span class="c1">// -&gt; negotiationneeded 발생</span>

<span class="c1">// 연결 초기 셋업시(바로 위 addStream), 또는 환경 변화로 재협상이 필요할때 발생</span>
<span class="nx">rtcPeerConnection</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">negotiationneeded</span><span class="dl">'</span><span class="p">,</span> <span class="k">async</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    
    <span class="c1">// caller에 접속하기 위한 경로 데이터를 생성해서 local session description에 설정</span>
    <span class="kd">const</span> <span class="nx">rtcSessionDescriptionInit</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">rtcPeerConnection</span><span class="p">.</span><span class="nx">createOffer</span><span class="p">();</span> <span class="c1">// { type: 'offer', sdp: '...' }</span>
    <span class="nx">rtcPeerConnection</span><span class="p">.</span><span class="nx">setLocalDescription</span><span class="p">(</span><span class="nx">rtcSessionDescriptionInit</span><span class="p">);</span> 
    
    <span class="c1">// 상대편에게 전송 -&gt; callee.js, onMessage('SDP')</span>
    <span class="nx">sendMessage</span><span class="p">(</span><span class="dl">'</span><span class="s1">SDP</span><span class="dl">'</span><span class="p">,</span> <span class="nx">rtcSessionDescriptionInit</span><span class="p">)</span>
<span class="p">});</span>
</code></pre></div></div>

<p><strong>callee.js</strong></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*...앞의 예제 내용에 이어서...*/</span>

<span class="kd">const</span> <span class="nx">rtcPeerConnection</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">RTCPeerConnection</span><span class="p">();</span>
<span class="nx">rtcPeerConnection</span><span class="p">.</span><span class="nx">addStream</span><span class="p">(</span><span class="nx">mediaStream</span><span class="p">);</span>

<span class="nx">onMessage</span><span class="p">(</span><span class="dl">'</span><span class="s1">SDP</span><span class="dl">'</span><span class="p">,</span> <span class="k">async</span> <span class="nx">payload</span> <span class="o">=&gt;</span> <span class="p">{</span>
  
  <span class="c1">// caller 에서 넘어온 sdp 데이터를 이용해서 remote session description을 설정  </span>
  <span class="kd">const</span> <span class="nx">rtcSessionDescription</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">RTCSessionDescription</span><span class="p">(</span><span class="nx">payload</span><span class="p">);</span>
  <span class="k">await</span> <span class="nx">rtcPeerConnection</span><span class="p">.</span><span class="nx">setRemoteDescription</span><span class="p">(</span><span class="nx">rtcSessionDescription</span><span class="p">);</span> 

  <span class="c1">// answer 타입의 session description을 생성해서 local에 설정하고 caller 로 다시 전송</span>
  <span class="kd">const</span> <span class="nx">rtcSessionDescriptionInit</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">rtcPeerConnection</span><span class="p">.</span><span class="nx">createAnswer</span><span class="p">();</span>
  <span class="k">await</span> <span class="nx">rtcPeerConnection</span><span class="p">.</span><span class="nx">setLocalDescription</span><span class="p">(</span><span class="nx">rtcSessionDescriptionInit</span><span class="p">);</span>
  <span class="nx">sendMessage</span><span class="p">(</span><span class="dl">'</span><span class="s1">SDP</span><span class="dl">'</span><span class="p">,</span> <span class="nx">rtcSessionDescriptionInit</span><span class="p">);</span>
<span class="p">});</span> 
</code></pre></div></div>

<p><strong>다시 caller.js</strong></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*...앞의 예제 내용에 이어서...*/</span>

<span class="nx">onMessage</span><span class="p">(</span><span class="dl">'</span><span class="s1">SDP</span><span class="dl">'</span><span class="p">,</span> <span class="k">async</span> <span class="nx">payload</span> <span class="o">=&gt;</span> <span class="p">{</span>
  
  <span class="c1">// callee 에서 넘어온 sdp 데이터를 이용해서 remote session description을 설정  </span>
  <span class="kd">const</span> <span class="nx">rtcSessionDescription</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">RTCSessionDescription</span><span class="p">(</span><span class="nx">payload</span><span class="p">);</span>
  <span class="k">await</span> <span class="nx">rtcPeerConnection</span><span class="p">.</span><span class="nx">setRemoteDescription</span><span class="p">(</span><span class="nx">rtcSessionDescription</span><span class="p">);</span> 
<span class="p">});</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">rtcPeerConnection.setRemoteDescription</code>를 호출하여 상대편 브라우저에 연결할 주소정보를 설정해주면 
이제 서로 상대방을 네트워크 상에서 식별할 준비가 된 것이다. 이 상태가 되면 <code class="language-plaintext highlighter-rouge">addstream</code> 이벤트가 발생한다. 
이 이벤트 객체에 담긴 stream을 <code class="language-plaintext highlighter-rouge">&lt;video /&gt;</code> 요소의 <code class="language-plaintext highlighter-rouge">srcObject</code>로 지정해서 이후 connection이 성립 한 후에
stream을 타고 전송되어 온 remote video data를 화면에 송출할 수 있다.</p>

<p><strong>caller.js</strong>, <strong>callee.js</strong> 동일하게</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*...앞의 예제 내용에 이어서...*/</span>

<span class="nx">rtcPeerConnection</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">addstream</span><span class="dl">'</span><span class="p">,</span> <span class="nx">e</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">remoteVideo</span><span class="dl">'</span><span class="p">).</span><span class="nx">srcObject</span> <span class="o">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">stream</span><span class="p">;</span>
<span class="p">});</span>
</code></pre></div></div>

<p>하지만 아직 몇가지 남은 숙제가 있다. 먼저 앞서 언급했듯이 <code class="language-plaintext highlighter-rouge">onMessage</code>, <code class="language-plaintext highlighter-rouge">sendMessage</code> 두 메소드가 아직 구현되지 않았다. 
이 두 메소드의 역할과 구현 방식에 대해서 다음 챕터에서 알아보자.</p>

<h2 id="signaling-server-구현">Signaling Server 구현</h2>

<p>위 코드에서 보이는바와 같이 WebRTC로 p2p 통신을 시작하기 전, 서로 어떻게 정보를 주고받아야 할지 협상을 거치는 단계에서도 
각 클라이언트간에 통신이 필요하다. 현재 구현되지 않은 <code class="language-plaintext highlighter-rouge">onMessage</code>, <code class="language-plaintext highlighter-rouge">sendMessage</code> 메소드가 이 부분이다.
아직 클라이언트간 p2p통신이 불가능한 상황에서 이 메시지들은 어떻게 주고 받아야 할까? 
바로 signaling server라 불리는 중계 서버가 그 역할을 한다.</p>

<p>이 signaling server의 구현은 표준으로 엄격하게 정해진 것은 없고 서비스의 요구사항과 상황에 따라 다양하게 구현하게 된다.
일반적으로 중계서버 역할을 하려면 서버에서 브라우저쪽으로 메시지 전달이 필요하기 때문에, WebSocket등을 이용해서 구현한다.</p>

<p>이 단계에서는 Socket.io를 사용하여 클라이언트끼리 메시지를 상호 전송해주는 단순한 Node.js 서버와, 
그에 상응하는 <code class="language-plaintext highlighter-rouge">onMessage</code>, <code class="language-plaintext highlighter-rouge">sendMessage</code> 메소드를 export하는 브라우저단 es6 module을 구현할 것이다.</p>

<h3 id="주의">주의</h3>
<p>지금 구현하는 signaling server는 접속자 식별기능이 없기 때문에 모든 메시지를 broadcasting한다. 로컬에서 테스트시 
caller, callee 각각 한개씩 이상의 브라우저를 띄울 경우, 각각의 연결 상태와 메시지가 일치하지 않아 정상적으로 작동이 불가능하다.</p>

<p>프로젝트 root directory에서 다음 커맨드를 실행하여 npm socket.io package를 설치하고 <code class="language-plaintext highlighter-rouge">server/index.js</code> 파일을 작성한다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm init
npm <span class="nb">install </span>socket.io node-static
</code></pre></div></div>

<p><strong>directory</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/  
├ package.json
│
├ server/
│└index.js
│
└ client/
  ├message.js
  ├ ...
</code></pre></div></div>

<p><strong>server/index.js</strong></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="kd">static</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">node-static</span><span class="dl">'</span><span class="p">);</span> 
<span class="kd">const</span> <span class="nx">http</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">http</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">socketIO</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">socket.io</span><span class="dl">'</span><span class="p">);</span>

<span class="c1">// client 파일들을 같은 서버에서 서빙한다.</span>
<span class="kd">const</span> <span class="nx">file</span> <span class="o">=</span> <span class="k">new</span> <span class="kd">static</span><span class="p">.</span><span class="nx">Server</span><span class="p">(</span><span class="dl">'</span><span class="s1">../client</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">app</span> <span class="o">=</span> <span class="nx">http</span>
  <span class="p">.</span><span class="nx">createServer</span><span class="p">(</span><span class="nx">file</span><span class="p">.</span><span class="nx">serve</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">file</span><span class="p">))</span>
  <span class="p">.</span><span class="nx">listen</span><span class="p">(</span><span class="mi">3000</span><span class="p">);</span>

<span class="c1">// 모든 클라이언트에서 발송된 메시지를 다른 모든 클라이언트에게 무차별적으로 전송한다.</span>
<span class="nx">socketIO</span>
  <span class="p">.</span><span class="nx">listen</span><span class="p">(</span><span class="nx">app</span><span class="p">).</span><span class="nx">sockets</span>
  <span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">connection</span><span class="dl">'</span><span class="p">,</span> <span class="nx">socket</span> <span class="o">=&gt;</span> <span class="p">(</span>
    <span class="nx">socket</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">message</span><span class="dl">'</span><span class="p">,</span> <span class="nx">message</span> <span class="o">=&gt;</span> <span class="nx">socket</span><span class="p">.</span><span class="nx">broadcast</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="dl">'</span><span class="s1">message</span><span class="dl">'</span><span class="p">,</span> <span class="nx">message</span><span class="p">))</span>
  <span class="p">));</span>
</code></pre></div></div>

<p>이제 <code class="language-plaintext highlighter-rouge">node server</code> 로 웹서버를 구동시키면 
<a href="http://localhost:3000/caller.html">http://localhost:3000/caller.html</a>,
<a href="http://localhost:3000/callee.html">http://localhost:3000/callee.html</a> 로 각각 접속 가능하다.</p>

<p><strong>caller.html</strong>, <strong>callee.html</strong></p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!--body 맨 하단--&gt;</span>
<span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"/socket.io/socket.io.js"</span><span class="nt">&gt;&lt;/script&gt;</span> <span class="c">&lt;!--서버측 socket.io에서 서빙되는 socket.io.js를 추가--&gt;</span>
<span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"script.js"</span> <span class="na">type=</span><span class="s">"module"</span><span class="nt">&gt;&lt;/script&gt;</span> <span class="c">&lt;!--type="module"--&gt;</span>
</code></pre></div></div>

<p>이제부터 위에서 작성한 웹서버를 통해서 접근할 것이기 때문에 es6 module import를 사용할 수 있다. <br />
html파일들에 <code class="language-plaintext highlighter-rouge">socket.io.js</code> 의존성을 추가해주고, module import를 사용하기 위해서 <code class="language-plaintext highlighter-rouge">type="module"</code>를 추가해준다.</p>

<p><strong>client/message.js</strong> 추가</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">socket</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">io</span><span class="p">();</span>

<span class="k">export</span> <span class="kd">const</span> <span class="nx">sendMessage</span> <span class="o">=</span> <span class="p">(</span><span class="nx">type</span><span class="p">,</span> <span class="nx">payload</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">socket</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="dl">'</span><span class="s1">message</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span><span class="nx">type</span><span class="p">,</span> <span class="nx">payload</span><span class="p">});</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">onMessage</span> <span class="o">=</span> <span class="p">(</span><span class="nx">type</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">socket</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">message</span><span class="dl">'</span><span class="p">,</span> <span class="nx">message</span> <span class="o">=&gt;</span> <span class="p">(</span>
  <span class="nx">message</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="nx">type</span> <span class="o">&amp;&amp;</span> <span class="nx">callback</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">payload</span><span class="p">)</span>
<span class="p">));</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">sendMessage</code>, <code class="language-plaintext highlighter-rouge">onMessage</code> 구현</p>

<p><strong>caller.js</strong>, <strong>callee.js</strong></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 각각 파일 최상단에 추가</span>
<span class="k">import</span> <span class="p">{</span><span class="nx">sendMessage</span><span class="p">,</span> <span class="nx">onMessage</span><span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">../message.js</span><span class="dl">"</span><span class="p">;</span>
</code></pre></div></div>

<p>여기까지 구현을 마치고 caller와 callee를 각각 브라우저에 띄워서 개발자 도구의 네트워크 탭을 보면
Signaling Server의 WebSocket을 통해서 서로 SDP를 교환하는 내용을 확인할 수 있다.</p>

<p><img src="https://user-images.githubusercontent.com/4980032/94692526-93beb680-036d-11eb-832e-4434958b0d03.png" alt="" /></p>

<p>브라우저가 크롬인 경우, <a href="chrome://webrtc-internals/">chrome://webrtc-internals/</a> 에 접속해보면
webrtc 관련한 네트워크 상태와 이벤트 발생을 모니터 할 수 있는데, 마지막으로 발생한 <code class="language-plaintext highlighter-rouge">signalingstatechange</code> 이벤트를 살펴보면
양측에서 상태가 <code class="language-plaintext highlighter-rouge">stable</code>로 변경된 것을 확인할 수 있다.</p>

<h2 id="rtc-연결-생성하기-2">RTC 연결 생성하기 (2)</h2>

<p>이제 Signaling Server까지 구현이 완료되었다! 그러면 이제 두개의 브라우저에 각각
<a href="http://localhost:3000/caller.html">caller App</a> 과 <a href="http://localhost:3000/callee.html">callee App</a> 을 띄우고 
서로 전송되는 두개의 화면을 볼수 있는 것일까?!</p>

<p>실제 실행해보면 아직 local video만 나오고 remote video는 나오지 않는다.
<a href="#rtc-연결-생성하기-1">RTC 연결 생성하기 (1)</a> 에서 언급한 것 처럼 실제 연결이 이루어지고 통신을 하기 위해서는 SDP와 ICE 두가지 정보가 교환되어야 하는데
아직 어떤 형식으로 데이터를 주고 받을지에 대한 정보를 담고 있는 <strong>(ICE - Interactive Connectivity Establishment)</strong> 를 
교환하는 단계에 대한 구현이 이루어 지지 않았다.</p>

<p>데이터를 주고받는 형식은 미디어 타입이나 브라우저 상황에 따라 한가지 이상의 방식으로 통신이 가능하기때문에 
ICE candidates라고 불리는 여러개의 후보군을 주고 받고, 이중에서 서로 가능한 방식이 있을때 최적이라고 판단되는 ICE를
골라서 협의하게 된다.</p>

<p>이 선택과정은 표준에 의해 구현된 브라우저가 실행하게 되므로 우리는 위에서 구축한 Signaling Server를 통해서
ICE candidates를 서로 전달해주기만 하면 된다.</p>

<h3 id="ice-교환-단계">ICE 교환 단계</h3>

<p><code class="language-plaintext highlighter-rouge">rtcPeerConnection.setLocalDescription</code>를 호출한 시점 이후로부터 각 <code class="language-plaintext highlighter-rouge">rtcPeerConnection</code>객체는 ICE candidate 를 생성할 수 있고
그때마다 <code class="language-plaintext highlighter-rouge">icecandidate</code>이벤트를 발생시킨다. 이 이벤트 객체에 ICE candidate 정보가 들어있으므로 이를 상대편에게 메시지로
전달하고, 또 메시지가 들어오면 <code class="language-plaintext highlighter-rouge">rtcPeerConnection.addIceCandidate</code> 메소드를 호출하여 상대편에서 보내온 ICE candidate를
로컬 rtcPeerConnection에 등록하면 된다.</p>

<p><strong>caller.js</strong>, <strong>callee.js</strong> 동일하게</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*...앞의 예제 내용에 이어서...*/</span>

<span class="c1">// 실제 로그를 찍어보면 이벤트는 총 세번 발생하는데, </span>
<span class="c1">// 각각 TCP, UDP 프로토콜 연결에 대한 ICE가 생성되고</span>
<span class="c1">// 마지막으로 ICE candidate의 끝을 나타내는 null값이 전달된다.</span>
<span class="nx">rtcPeerConnection</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">icecandidate</span><span class="dl">'</span><span class="p">,</span> <span class="nx">e</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">candidate</span> <span class="o">===</span> <span class="kc">null</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="nx">sendMessage</span><span class="p">(</span><span class="dl">'</span><span class="s1">ICE</span><span class="dl">'</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">candidate</span><span class="p">)</span>  
<span class="p">});</span>

<span class="nx">onMessage</span><span class="p">(</span><span class="dl">'</span><span class="s1">ICE</span><span class="dl">'</span><span class="p">,</span> <span class="nx">payload</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">rtcPeerConnection</span><span class="p">.</span><span class="nx">addIceCandidate</span><span class="p">(</span><span class="k">new</span> <span class="nx">RTCIceCandidate</span><span class="p">(</span><span class="nx">payload</span><span class="p">));</span>
<span class="p">})</span>
</code></pre></div></div>

<p>여기까지 수행하면 두개의 브라우저에 각각 local, remote 화면이 출력되는 것을 확인할 수 있으며, 
서로 다른 브라우저 프로세스 사이에서 시그널 서버를 통하지 않고 직접 통신하여 비디오 스트림을 전송하는 것을 확인할 수 있다.
실제 전송되는 데이터에 대한 실시간 모니터링을 <a href="chrome://webrtc-internals/">chrome://webrtc-internals/</a>에서 확인할 수 있다.
다만 현재까지는 하나의 컴퓨터에서 실행하고 있기 때문에 local 비디오나 remote 비디오나 같은 화면이 보일텐데 
네트워크를 통하기 때문에 자세히 보면 미세한 레이턴시가 발생하는것을 알 수 있다.</p>

<p>여기까지의 통신과정을 시퀀스 다이어그램으로 정리하면 아래와 같다.</p>

<div class="mermaid"> 
sequenceDiagram
Participant caller
Participant signal server
Participant callee
par
caller-&gt;&gt;caller: createOffer()
Note left of caller: LocalDescription = offer
caller-&gt;&gt;signal server: offerSDP
signal server-&gt;&gt;callee: offerSDP
Note right of callee: RemoteDescription = offer
callee-&gt;&gt;callee: createAnswer()
Note right of callee: LocalDescription = answer
callee--&gt;&gt;signal server: answerSDP
signal server--&gt;&gt;caller: answerSDP
Note left of caller: RemoteDescription = answer
and
callee-&gt;&gt;signal server: IceCandidate(callee) x N
signal server-&gt;&gt;caller: IceCandidate(callee) x N
Note left of caller: IceCandidates = iceCandidate(callee) x N
and
caller-&gt;&gt;signal server: IceCandidate(caller) x N
signal server-&gt;&gt;callee: IceCandidate(caller) x N
Note right of callee: IceCandidates = iceCandidate(caller) x N
end

Note over caller, callee: negotiation end

caller-&gt;&gt;callee: p2p Media streaming(Audio, Video, Data)
callee-&gt;&gt;caller: p2p Media streaming(Audio, Video, Data)
</div>

<h2 id="caller-callee-코드-통합-및-정리">Caller, Callee 코드 통합 및 정리</h2>

<p>여태까지 로직 구분을 간단히 하기 위해 <code class="language-plaintext highlighter-rouge">Caller</code>, <code class="language-plaintext highlighter-rouge">Callee</code>를 구분해서 작성했지만, 
실제 사용시에는 두 역할에 따라 엔드포인트가 구분되어 있지 않는 경우가 많고, 로직도 중복된 부분이 많아서 적당한 UI와 함께
하나의 App으로 통합해도 무리가 없다.</p>

<p>두 부분을 하나로 통합하고 중복된 부분을 정리한 결과는 다음과 같다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span><span class="nx">onMessage</span><span class="p">,</span> <span class="nx">sendMessage</span><span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./message.js</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">localVideo</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">localVideo</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">remoteVideo</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">remoteVideo</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">rtcPeerConnection</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">RTCPeerConnection</span><span class="p">();</span>

<span class="kd">const</span> <span class="nx">sendSdpOffer</span> <span class="o">=</span> <span class="k">async</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">rtcSessionDescriptionInit</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">rtcPeerConnection</span><span class="p">.</span><span class="nx">createOffer</span><span class="p">();</span>
  <span class="k">await</span> <span class="nx">rtcPeerConnection</span><span class="p">.</span><span class="nx">setLocalDescription</span><span class="p">(</span><span class="nx">rtcSessionDescriptionInit</span><span class="p">);</span>
  <span class="nx">sendMessage</span><span class="p">(</span><span class="dl">'</span><span class="s1">SDP</span><span class="dl">'</span><span class="p">,</span> <span class="nx">rtcSessionDescriptionInit</span><span class="p">)</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">sendSdpAnswer</span> <span class="o">=</span> <span class="k">async</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">rtcSessionDescriptionInit</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">rtcPeerConnection</span><span class="p">.</span><span class="nx">createAnswer</span><span class="p">();</span>
  <span class="k">await</span> <span class="nx">rtcPeerConnection</span><span class="p">.</span><span class="nx">setLocalDescription</span><span class="p">(</span><span class="nx">rtcSessionDescriptionInit</span><span class="p">);</span>
  <span class="nx">sendMessage</span><span class="p">(</span><span class="dl">'</span><span class="s1">SDP</span><span class="dl">'</span><span class="p">,</span> <span class="nx">rtcSessionDescriptionInit</span><span class="p">);</span>
<span class="p">};</span>

<span class="nb">navigator</span><span class="p">.</span><span class="nx">mediaDevices</span>
  <span class="p">.</span><span class="nx">getUserMedia</span><span class="p">({</span><span class="na">video</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="na">audio</span><span class="p">:</span> <span class="kc">false</span><span class="p">})</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">mediaStream</span> <span class="o">=&gt;</span> <span class="nx">rtcPeerConnection</span><span class="p">.</span><span class="nx">addStream</span><span class="p">(</span><span class="nx">localVideo</span><span class="p">.</span><span class="nx">srcObject</span> <span class="o">=</span> <span class="nx">mediaStream</span><span class="p">));</span>

<span class="c1">// exchange SDP</span>
<span class="nx">rtcPeerConnection</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">negotiationneeded</span><span class="dl">'</span><span class="p">,</span> <span class="nx">sendSdpOffer</span><span class="p">)</span>
<span class="nx">onMessage</span><span class="p">(</span><span class="dl">'</span><span class="s1">SDP</span><span class="dl">'</span><span class="p">,</span> <span class="k">async</span> <span class="nx">descriptionInit</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">rtcSessionDescription</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">RTCSessionDescription</span><span class="p">(</span><span class="nx">descriptionInit</span><span class="p">);</span>
  <span class="k">await</span> <span class="nx">rtcPeerConnection</span><span class="p">.</span><span class="nx">setRemoteDescription</span><span class="p">(</span><span class="nx">rtcSessionDescription</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">descriptionInit</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">offer</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">await</span> <span class="nx">sendSdpAnswer</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">})</span>

<span class="c1">// exchange ICE</span>
<span class="nx">rtcPeerConnection</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">icecandidate</span><span class="dl">'</span><span class="p">,</span> <span class="nx">e</span> <span class="o">=&gt;</span> <span class="nx">e</span><span class="p">.</span><span class="nx">candidate</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="nx">sendMessage</span><span class="p">(</span><span class="dl">'</span><span class="s1">ICE</span><span class="dl">'</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">candidate</span><span class="p">));</span>
<span class="nx">onMessage</span><span class="p">(</span><span class="dl">'</span><span class="s1">ICE</span><span class="dl">'</span><span class="p">,</span> <span class="nx">candidateInit</span> <span class="o">=&gt;</span> <span class="nx">rtcPeerConnection</span><span class="p">.</span><span class="nx">addIceCandidate</span><span class="p">(</span><span class="k">new</span> <span class="nx">RTCIceCandidate</span><span class="p">(</span><span class="nx">candidateInit</span><span class="p">)))</span>

<span class="c1">// handle remote stream</span>
<span class="nx">rtcPeerConnection</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">addstream</span><span class="dl">'</span><span class="p">,</span> <span class="nx">e</span> <span class="o">=&gt;</span> <span class="nx">remoteVideo</span><span class="p">.</span><span class="nx">srcObject</span> <span class="o">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">stream</span><span class="p">);</span>


</code></pre></div></div>
:ET