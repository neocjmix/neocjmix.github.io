---
layout: post
tags: WebRTC Node.js
title: p2p 화상채팅 구현 (1) <small>feat. WebRTC</small>
published: false
---

> WebRTC(Web Real-Time Communications)란, 웹 어플리케이션(최근에는 android 및 ios도 지원) 및 사이트들이 
> 별도의 소프트웨어 없이 음성, 영상 미디어 혹은 텍스트, 파일 같은 데이터를 브라우져끼리 주고 받을 수 있게 만든 기술이다. 
> WebRTC로 구성된 프로그램들은 별도의 플러그인이나 소프트웨어 없이 p2p 화상회의 및 데이터 공유를 한다. 
> \- [developer.mozilla.org](https://developer.mozilla.org/ko/docs/Web/API/WebRTC_API)

p2p 화상채팅을 구현하기 위해서 사용되는 표준 기술인 WebRTC는 만만한 기술은 아니다. 
해결해야할 기술적 과제는 복잡한 반면 표준 정의는 느슨하다. 
실제 구현시 발생하는 여러가지 문제들을 best practice로 해결하기란 
쉽지 않은 일이며, 잘 구현된 라이브러리를 사용하는 것이 현명할 수도 있다. 다만 라이브러리를 사용한다 해도
그 기반을 이루고 있는 기술에 대한 이해는 필수적이다.

이 연재는 p2p 비디오 스트리밍을 위한 기술적 요구사항들과 이를 해결하기 위한 WebRTC 기술의 구성요소들, 
구현시 발생가능한 문제들에 대한 기본적인 해결방법에 대한 이해를 위한 스터디 기록이다.

목표는 가장 단순한 구현부터 시작해서 AWS를 통해 모바일 크로스 플랫폼 간에 1:1 p2p통신을 이용하여 영상 및 채팅 메시지를 전송할수 
있도록 구현하는 것 까지이다.

boilerplate code를 줄이고 빠른 시작이 가능하게 하기 위해 별도의 bundler를 사용하지 않고 es6의 module API를 사용할 것이다. 

## 클라이언트 구성

1:1 화상채팅을 연결하는 단계의 로직은 요청하는 쪽과 받는쪽의 로직으로 나눌 수 있다.
완성단계에서는 하나의 화면으로 합쳐지겠지만 과정의 이해를 쉽게 하기위해 처음에는 두 화면으로 나누어서 구성한다. 

```
/
└─ client/
    ├─ caller/
    │  ├ index.html
    │  └ script.js
    └─ callee/
        ├ index.html
        └ script.js
```

## 화면에 웹캠 스트리밍 표시하기

복잡한 기술적 사항을 다루느라 흥미를 잃기 전에 바로 화면부터 띄워보자. 

**caller/index.html**, **callee/index.html** 동일

```html
<!doctype html>
<html>
<head>
    <meta charset="UTF-8">
    <title>WebRTC</title>
</head>
<body>
<!--내 얼굴이 나올 video 요소-->
<video id="localVideo" autoplay width="480px"></video>
<script src="script.js"></script>
</body>
</html>
```

**caller/script.js**, **callee/script.js** 동일

```javascript
(async () => {
  const localVideo = document.getElementById('localVideo');
  const mediaStream = await navigator.mediaDevices.getUserMedia({
    video: true,
    audio: false,
  });
  localVideo.srcObject = mediaStream;
})();
```

위와 같이 작성하고 caller/index.html 또는 callee/index.html 을 브라우저로 띄우면 사용자에게 비디오 전송 허용을 요청하는 대화상자를 띄운 후에 
웹캠 화면이 브라우저에 나타나기 시작한다.

## RTC 연결 생성하기 (1)

WebRTC 통신은 `RTCPeerConnection` 객체를 통해서 이루어진다. caller와 callee는 이 객체를 통해서 상대편 단말에 메시지를 보내 
어떤 경로를 통해서 접근해야 하는지와 **(SDP - Session Description Protocol)**
어떤 형식으로 데이터를 주고 받을지 **(ICE - Interactive Connectivity Establishment)** 를 협의한 후 실제 데이터를 주고 받게 된다.

### SDP 교환 단계

두 클라이언트는 아래 과정을 거쳐서 서로에게 어떻게 접속해야 할지에 대한 정보 (localDescription, remoteDescription)를 교환한다.

<div class="mermaid"> 
sequenceDiagram
caller->>caller: createOffer()
Note left of caller: LocalDescription = offer
caller->>callee: offerSDP
Note right of callee: RemoteDescription = offer
callee->>callee: createAnswer()
Note right of callee: LocalDescription = answer
callee-->>caller: answerSDP
Note left of caller: RemoteDescription = answer 
</div>

아래 예제는 클라이언트 간 메시지 교환을 위한 `onMessage`, `sendMessage` 메소드가 구현되어 있다고 가정하고 작성한 것이다.  
(이 두 메소드의 구현은 조금 뒤에 다룬다.)

메시지 교환 순서의 이해를 돕기 위해 caller, callee 사이에 메시지가 오가는 순서대로 작성한다.  

**caller/script.js**

```javascript
(async () => {
    /*...앞의 예제 내용에 이어서...*/
    
    const rtcPeerConnection = new RTCPeerConnection();
    
    // 연결 초기 셋업시(바로 아래 addStream), 또는 환경 변화로 재협상이 필요할때 발생
    rtcPeerConnection.addEventListener('negotiationneeded', async () => {
        // caller에 접속하기 위한 경로 데이터를 생성해서 local session description에 설정
        const rtcSessionDescriptionInit = await rtcPeerConnection.createOffer(); // { type: 'offer', sdp: '...' }
        rtcPeerConnection.setLocalDescription(rtcSessionDescriptionInit); 
        
        // 상대편에게 전송 -> callee/script.js, onMessage('SDP')
        sendMessage('SDP', rtcSessionDescriptionInit)
    })
    
    rtcPeerConnection.addStream(mediaStream); // -> negotiationneeded
})()
```

**callee/script.js**

```javascript
(async () => {
    /*...앞의 예제 내용에 이어서...*/
    
    const rtcPeerConnection = new RTCPeerConnection();
    rtcPeerConnection.addStream(mediaStream);

    onMessage('SDP', async payload => {
      // caller 에서 넘어온 sdp 데이터를 이용해서 remote session description을 설정  
      const rtcSessionDescription = new RTCSessionDescription(payload);
      await rtcPeerConnection.setRemoteDescription(rtcSessionDescription); 

      // answer 타입의 session description을 생성해서 local에 설정하고 caller 로 다시 전송
      const rtcSessionDescriptionInit = await rtcPeerConnection.createAnswer();
      await rtcPeerConnection.setLocalDescription(rtcSessionDescriptionInit);
      sendMessage('SDP', rtcSessionDescriptionInit);
    })  
})()
```

**다시 caller/script.js**

```javascript
(async () => {
    /*...앞의 예제 내용에 이어서...*/
    
    onMessage('SDP', async payload => {
      // callee 에서 넘어온 sdp 데이터를 이용해서 remote session description을 설정  
      const rtcSessionDescription = new RTCSessionDescription(payload);
      await rtcPeerConnection.setRemoteDescription(rtcSessionDescription); 
    })
})()
```

## Signaling Server 구현

위 코드에서 보이는바와 같이 WebRTC로 p2p 통신을 시작하기 전, 서로 어떻게 정보를 주고받아야 할지 협상을 거치는 단계에서도 
각 클라이언트간에 통신이 필요하다. 현재 구현되지 않은 `onMessage`, `sendMessage` 메소드가 이 부분이다.
아직 클라이언트간 p2p통신이 불가능한 상황에서 이 메시지들은 어떻게 주고 받아야 할까? 
바로 signaling server라 불리는 중계 서버가 그 역할을 한다.

이 signaling server의 구현은 표준으로 정해진 것이 없고 알아서 잘 구현하면 되는데, 서비스의 요구사항과 상황에 따라 다양한 
로직이 필요하기 때문에 엄격하게 정의되지 않은것으로 보인다. 
일반적으로 중계서버 역할을 하려면 서버에서 브라우저쪽으로 메시지 전달이 필요하기 때문에, WebSocket등을 이용해서 구현한다.

이 단계에서는 Socket.io를 사용하여 클라이언트끼리의 메시지를 broadcasting해주는 단순한 Node.js 서버와, 
그에 상응하는 `onMessage`, `sendMessage` 메소드를 export하는 브라우저단 es6 module을 구현할 것이다.

프로젝트 root directory에서 다음 커맨드를 실행하여 npm socket.io package를 설치하고 `server/index.js` 파일을 작성한다.

```shell
npm init
npm install socket.io node-static
```

**directory**

```
/  
├ package.json
│
├ server/
│└index.js
│
└ client/
  ├message.js
  ├ ...
```

**server/index.js**

```javascript
const static = require('node-static'); 
const http = require('http');
const socketIO = require('socket.io');

// client 파일들을 같은 서버에서 서빙한다.
const file = new static.Server('../client');
const app = http
  .createServer(file.serve.bind(file))
  .listen(3000);

// 모든 클라이언트에서 발송된 메시지를 다른 모든 클라이언트에게 무차별적으로 전송한다.
socketIO
  .listen(app).sockets
  .on('connection', socket => (
    socket.on('message', message => socket.broadcast.emit('message', message))
  ));
```

이제 `node server` 로 웹서버를 구동시키면 
[http://localhost:3000/caller](http://localhost:3000/caller),
[http://localhost:3000/callee](http://localhost:3000/callee) 로 각각 접속 가능하다.


**caller/index.html**, **callee/index.html**

```html
<!--body 맨 하단-->
<script src="/socket.io/socket.io.js"></script> <!--서버측 socket.io에서 서빙되는 socket.io.js를 추가-->
<script src="script.js" type="module"></script> <!--type="module"-->
```

이제부터 위에서 작성한 웹서버를 통해서 접근할 것이기 때문에 es6 module import를 사용할 수 있다.   
html파일들에 `socket.io.js` 의존성을 추가해주고, module import를 사용하기 위해서 `type="module"`를 추가해준다.

**client/message.js** 추가

```javascript
const socket = window.io();

export const sendMessage = (type, payload) => socket.emit('message', {type, payload});
export const onMessage = (type, callback) => socket.on('message', message => (
  message.type === type && callback(message.payload)
));
```

`sendMessage`, `onMessage` 구현

**caller/script.js**, **callee/script.js**

```javascript
// 각각 파일 최상단에 추가
import {sendMessage, onMessage} from "../message.js";
```

여기까지 구현을 마치고 caller와 callee를 각각 브라우저에 띄워서 개발자 도구의 네트워크 탭을 보면
Signaling Server의 WebSocket을 통해서 서로 SDP를 교환하는 내용을 확인할 수 있다.
 

<div class="mermaid"> 
sequenceDiagram
rect rgba(230,230,240)
Note over caller, callee: negotiation
caller->>caller: createOffer()
Note left of caller: LocalDescription = offer
caller->>callee: offerSDP
Note right of callee: RemoteDescription = offer
callee->>callee: createAnswer()
Note right of callee: LocalDescription = answer
callee-->>caller: answerSDP
Note left of caller: RemoteDescription = answer
par
caller->>callee: IceCandidate(caller) x N
Note right of callee: IceCandidates = iceCandidate(caller) x N
and
callee->>caller: IceCandidate(callee) x N
Note left of caller: IceCandidates = iceCandidate(callee) x N
end
end
caller->callee: p2p Media streaming(Audio, Video, Data) 
</div>
